"""
Utility functions related to loading
and saving PyUnity meshes and scenes.

This will be imported as ``pyunity.Loader``.

"""

from .vector3 import Vector3
from .quaternion import Quaternion
from .meshes import Mesh
from .core import *
from .scenes import SceneManager
from .files import Behaviour
from .render import Camera
from .audio import AudioSource
from .physics import AABBoxCollider, SphereCollider
from uuid import uuid4
import json
import os
# import random

def LoadObj(filename):
    """
    Loads a .obj file to a PyUnity mesh.

    Parameters
    ----------
    filename : str
        Name of file

    Returns
    -------
    Mesh
        A mesh of the object file

    """
    vertices = []
    normals = []
    faces = []

    for line in open(filename, "r"):
        if line.startswith("#"):
            continue
        values = line.split()
        if not values:
            continue
        if values[0] == "v":
            v = Vector3(float(values[1]), float(values[3]), float(values[2]))
            vertices.append(v)
        elif values[0] == "f":
            face = []
            for v in values[1:]:
                w = v.split("/")
                face.append(int(w[0]) - 1)
            face.reverse()
            faces.append(face)

    for face in faces:
        a = vertices[face[2]] - vertices[face[1]]
        b = vertices[face[0]] - vertices[face[1]]
        normal = a.cross(b).normalized()
        normals.append(normal)

    return Mesh(vertices, faces, normals)

def SaveObj(mesh, name, filePath=None):
    if filePath:
        directory = os.path.dirname(os.path.realpath(filePath))
    else:
        directory = os.getcwd()

    with open(os.path.join(directory, name + ".obj"), "w+") as f:
        for vertex in mesh.verts:
            f.write("v " + " ".join(map(str, round(vertex, 8))) + "\n")
        for normal in mesh.normals:
            f.write("vn " + " ".join(map(str, round(normal, 8))) + "\n")
        for face in mesh.triangles:
            face = " ".join([
                str(face[0] + 1) + "//" + str(face[0] + 1),
                str(face[1] + 1) + "//" + str(face[1] + 1),
                str(face[2] + 1) + "//" + str(face[2] + 1),
            ])
            f.write("f " + face + "\n")

def LoadMesh(filename):
    """
    Loads a .mesh file generated by
    `SaveMesh`. It is optimized for faster
    loading.

    Parameters
    ----------
    filename : str
        Name of file relative to the cwd

    Returns
    -------
    Mesh
        Generated mesh

    """
    with open(filename, "r") as f:
        lines = list(map(lambda x: x.rstrip(), f.readlines()))
        if "" in lines:
            lines.remove("")

    vertices = list(map(float, lines[0].split("/")))
    vertices = [
        Vector3(vertices[i], vertices[i + 1], vertices[i + 2]) for i in range(0, len(vertices), 3)
    ]
    faces = list(map(int, lines[1].split("/")))
    faces = [
        [faces[i], faces[i + 1], faces[i + 2]] for i in range(0, len(faces), 3)
    ]
    normals = list(map(float, lines[2].split("/")))
    normals = [
        Vector3(normals[i], normals[i + 1], normals[i + 2]) for i in range(0, len(normals), 3)
    ]
    texcoords = list(map(float, lines[3].split("/")))
    texcoords = [
        [texcoords[i], texcoords[i + 1]] for i in range(0, len(texcoords), 2)
    ]
    return Mesh(vertices, faces, normals, texcoords)

def SaveMesh(mesh, name, filePath=None):
    """
    Saves a mesh to a .mesh file
    for faster loading.

    Parameters
    ----------
    mesh : Mesh
        Mesh to save
    name : str
        Name of the mesh
    filePath : str, optional
        Pass in `__file__` to save in
        directory of script, otherwise
        pass in the path of where you
        want to save the file. For example, if you
        want to save in C:\Downloads, then give
        "C:\Downloads\mesh.mesh". If not
        specified, then the mesh is saved
        in the cwd.

    """
    if filePath:
        directory = os.path.dirname(os.path.realpath(filePath))
    else:
        directory = os.getcwd()

    with open(os.path.join(directory, name + ".mesh"), "w+") as f:
        i = 0
        for vertex in mesh.verts:
            i += 1
            f.write(str(round(vertex.x, 8)) + "/")
            f.write(str(round(vertex.y, 8)) + "/")
            f.write(str(round(vertex.z, 8)))
            if i != len(mesh.verts):
                f.write("/")
        f.write("\n")

        i = 0
        for triangle in mesh.triangles:
            i += 1
            j = 0
            for item in triangle:
                j += 1
                f.write(str(item))
                if i != len(mesh.triangles) or j != 3:
                    f.write("/")
        f.write("\n")

        i = 0
        for normal in mesh.normals:
            i += 1
            f.write(str(round(normal.x, 8)) + "/")
            f.write(str(round(normal.y, 8)) + "/")
            f.write(str(round(normal.z, 8)))
            if i != len(mesh.normals):
                f.write("/")
        f.write("\n")

        i = 0
        for texcoord in mesh.texcoords:
            i += 1
            f.write(str(texcoord[0]) + "/")
            f.write(str(texcoord[1]))
            if i != len(mesh.texcoords):
                f.write("/")
        f.write("\n")

def SaveScene(scene, filePath=None):
    if filePath:
        directory = os.path.dirname(os.path.realpath(filePath))
    else:
        directory = os.getcwd()
    
    f = open(os.path.join(directory, scene.name + ".scene"), "w+")
    f.write("Scene : " + str(uuid4()) + "\n")
    f.write("    name: " + json.dumps(scene.name) + "\n")
    
    ids = {}
    for gameObject in scene.gameObjects:
        uuid = str(uuid4())
        
        ids[id(gameObject)] = uuid
        f.write("GameObject : " + uuid + "\n")
        f.write("    name: " + json.dumps(gameObject.name) + "\n")
        f.write("    tag: " + str(gameObject.tag.tag) + "\n")
        
        uuid = str(uuid4())
        
        ids[id(gameObject.transform)] = uuid

        f.write("    transform: " + uuid + "\n")

        for component in gameObject.components:
            if id(component) in ids:
                uuid = ids[id(component)]
            else:
                uuid = str(uuid4())
                
                ids[id(component)] = uuid
            
            if issubclass(type(component), Behaviour):
                name = type(component).__name__ + "(Behaviour)"
            else:
                name = type(component).__name__ + "(Component)"
            f.write(name + " : " + uuid + "\n")
            
            f.write("    gameObject: " + ids[id(gameObject)] + "\n")
            for attr in component.attrs:
                value = getattr(component, attr)
                if hasattr(value, "_convert"):
                    written = value._convert()
                else:
                    written = str(value)
                f.write("    " + attr + ": " + written + "\n")

class ObjectInfo:
    def __init__(self, uuid, type, attrs):
        self.uuid = uuid
        self.type = type
        self.attrs = attrs
    
    def __getattr__(self, attr):
        return self.attrs[attr]

components = {
    "Transform": Transform,
    "Camera": Camera,
    "Light": Light,
    "MeshRenderer": MeshRenderer,
    "AABBoxCollider": AABBoxCollider,
    "SphereCollider": SphereCollider,
    "AudioSource": AudioSource
}
"""List of all components by name"""

def LoadScene(filename):
    with open(filename, "r") as f:
        lines = f.read().rstrip().splitlines()
    data = []
    for line in lines:
        if not line.startswith("    "):
            data.append([line])
        else:
            data[-1].append(line)
    
    infos = []
    for info in data:
        type_, uuid = info[0].split(" : ")
        attrs = {attr: value for attr, value in map(lambda x: x[4:].split(": "), info[1:])}
        infos.append(ObjectInfo(uuid, type_, attrs))
    gameObjectInfo = list(filter(lambda x: x.type == "GameObject", infos))
    componentInfo = list(filter(lambda x: "(Component)" in x.type, infos))
    behaviourInfo = list(filter(lambda x: "(Behaviour)" in x.type, infos))
    
    scene_info = infos.pop(0)
    scene = SceneManager.AddScene(json.loads(scene_info.name))
    scene.Remove(scene.gameObjects[0])
    scene.Remove(scene.gameObjects[0])

    ids = {}

    gameObjects = []
    for info in gameObjectInfo:
        gameObject = GameObject.BareObject(json.loads(info.name))
        gameObjects.append(gameObject)
        gameObject.tag = Tag(int(info.tag))
        ids[info.uuid] = gameObject
    
    for info in componentInfo:
        gameObject = ids[info.gameObject]
        del info.attrs["gameObject"]
        component = components[info.type[:-11]]
        component = gameObject.AddComponent(component)
        ids[info.uuid] = component
        for name, value in reversed(info.attrs.items()):
            if value in ids:
                setattr(component, name, ids[value])
            elif value.startswith("Vector3("):
                setattr(component, name, Vector3(*list(map(float, value[8:-1].split(", ")))))
            elif value.startswith("Quaternion("):
                setattr(component, name, Quaternion(*list(map(float, value[11:-1].split(", ")))))
    
    for gameObject in gameObjects:
        scene.Add(gameObject)

    return scene

class Primitives:
    """
    Primitive preloaded meshes.
    Do not instantiate this class.

    """

    __path = os.path.dirname(os.path.realpath(__file__))
    cube = LoadMesh(os.path.join(__path, "primitives/cube.mesh"))
    quad = LoadMesh(os.path.join(__path, "primitives/quad.mesh"))
    double_quad = LoadMesh(os.path.join(__path, "primitives/double_quad.mesh"))
    sphere = LoadMesh(os.path.join(__path, "primitives/sphere.mesh"))
    capsule = LoadMesh(os.path.join(__path, "primitives/capsule.mesh"))
    cylinder = LoadMesh(os.path.join(__path, "primitives/cylinder.mesh"))
