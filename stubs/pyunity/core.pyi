"""
Core classes for the PyUnity library.

This module has some key classes used throughout PyUnity, and
have to be in the same file due to references both ways. Usually
when you create a scene, you should never create Components
directly, instead add them with AddComponent.

Example
-------
To create a GameObject with 2 children, one of which has its own child,
and all have MeshRenderers:

    >>> from pyunity import * # Import
    Loaded config
    Trying GLFW as a window provider
    GLFW doesn't work, trying PySDL2
    Trying PySDL2 as a window provider
    Using window provider PySDL2
    Loaded PyUnity version 0.8.3
    >>> mat = Material(RGB(255, 0, 0)) # Create a default material
    >>> root = GameObject("Root") # Create a root GameObjects
    >>> child1 = GameObject("Child1", root) # Create a child
    >>> child1.transform.localPosition = Vector3(-2, 0, 0) # Move the child
    >>> renderer = child1.AddComponent(MeshRenderer) # Add a renderer
    >>> renderer.mat = mat # Add a material
    >>> renderer.mesh = Mesh.cube(2) # Add a mesh
    >>> child2 = GameObject("Child2", root) # Create another child
    >>> renderer = child2.AddComponent(MeshRenderer) # Add a renderer
    >>> renderer.mat = mat # Add a material
    >>> renderer.mesh = Mesh.quad(1) # Add a mesh
    >>> grandchild = GameObject("Grandchild", child2) # Add a grandchild
    >>> grandchild.transform.localPosition = Vector3(0, 5, 0) # Move the grandchild
    >>> renderer = grandchild.AddComponent(MeshRenderer) # Add a renderer
    >>> renderer.mat = mat # Add a material
    >>> renderer.mesh = Mesh.cube(3) # Add a mesh
    >>> root.transform.List() # List all GameObjects
    /Root
    /Root/Child1
    /Root/Child2
    /Root/Child2/Grandchild
    >>> child1.components # List child1's components
    [<Transform position=Vector3(-2, 0, 0) rotation=Quaternion(1, 0, 0, 0) scale=Vector3(1, 1, 1) path="/Root/Child1">, <pyunity.core.MeshRenderer object at 0x0A929460>]
    >>> child2.transform.children # List child2's children
    [<Transform position=Vector3(0, 5, 0) rotation=Quaternion(1, 0, 0, 0) scale=Vector3(1, 1, 1) path="/Root/Child2/Grandchild">]

"""

__all__ = ["Component", "GameObject", "Light", "SingleComponent",
           "MeshRenderer", "Tag", "Transform", "ShowInInspector",
           "HideInInspector", "LightType"]

from typing import Generator, List, Optional, Type, TypeVar, Union, Dict
from .values import Vector3, Quaternion, Color, Material
from .scenes import Scene
from .meshes import Mesh
import enum

T = TypeVar("T")

class Tag:
    tags: List[str] = ...
    tag: int
    tagName: str
    @classmethod
    def AddTag(cls, name: str) -> int: ...
    def __init__(self, tagNumOrName: Union[str, int]) -> None: ...

class GameObject:
    name: str
    components: List[Component]
    tag: Tag
    transform: Transform
    enabled: bool
    scene: Scene
    def __init__(self, name: str = ..., parent: Optional[GameObject] = ...) -> None: ...
    @staticmethod
    def BareObject(name: str = ...) -> GameObject: ...
    def AddComponent(self, componentClass: Type[T]) -> T: ...
    def GetComponent(self, componentClass: Type[T]) -> T: ...
    def RemoveComponent(self, componentClass: Type[T]) -> None: ...
    def GetComponents(self, componentClass: Type[T]) -> List[T]: ...
    def RemoveComponents(self, componentClass: Type[T]) -> None: ...
    def __repr__(self) -> str: ...
    def __str__(self) -> str: ...

class HideInInspector:
    type: Type[T]
    default: T
    name: Optional[str]
    def __init__(self, type: Optional[Type[T]] = ..., default: Optional[T] = ...) -> None: ...

class ShowInInspector(HideInInspector):
    def __init__(self, type: Optional[Type[T]] = ..., default: Optional[T] = ..., name: Optional[str] = ...): ...

class Component:
    shown: Dict[str, HideInInspector] = ...
    saved: Dict[str, HideInInspector] = ...
    gameObject: GameObject
    transform: Transform
    enabled: bool
    def __init__(self, transform: Transform, is_dummy: bool = ...) -> None: ...
    def __init_subclass__(cls) -> None: ...
    def AddComponent(self, componentClass: Type[T]) -> T: ...
    def GetComponent(self, componentClass: Type[T]) -> T: ...
    def RemoveComponent(self, componentClass: Type[T]) -> None: ...
    def GetComponents(self, componentClass: Type[T]) -> List[T]: ...
    def RemoveComponents(self, componentClass: Type[T]) -> None: ...
    @property
    def scene(self) -> Scene: ...

class SingleComponent(Component): ...

class Transform(SingleComponent):
    localPosition: Vector3 = ...
    localRotation: Quaternion = ...
    localScale: Vector3 = ...
    parent: Optional[Transform]
    children: List[Transform]
    @property
    def position(self) -> Vector3: ...
    @property
    def rotation(self) -> Quaternion: ...
    @property
    def localEulerAngles(self) -> Vector3: ...
    @property
    def eulerAngles(self) -> Vector3: ...
    @property
    def scale(self) -> Vector3: ...

    def __init__(self, transform: Transform) -> None: ...
    def ReparentTo(self, parent: Transform) -> None: ...
    def List(self) -> None: ...
    def GetDescendants(self) -> Generator[Transform]: ...
    def FullPath(self) -> str: ...
    def LookAtTransform(self, transform: Transform) -> None: ...
    def LookAtGameObject(self, gameObject: GameObject) -> None: ...
    def LookAtPoint(self, vec: Vector3) -> None: ...
    def LookInDirection(self, vec: Vector3) -> None: ...
    def __repr__(self) -> str: ...
    def __str__(self) -> str: ...

class LightType(enum.IntEnum):
    Point: LightType = ...
    Directional: LightType = ...
    Spot: LightType = ...

class Light(SingleComponent):
    intensity: int = ...
    color: Color = ...
    type: LightType = ...

class MeshRenderer(SingleComponent):
    DefaultMaterial: Material = ...
    mesh: Mesh = ...
    mat: Material = ...
    def Render(self) -> None: ...
